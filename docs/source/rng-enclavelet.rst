RNG enclavelet
##############

`The RNG enclavelet project can be found on GitHub here <https://github.com/corda/oblivium-public/samples/rng>`_.

Overview
--------

This project shows you how to generate and sign random numbers. Users who remotely attest with the enclave can be sure
that the stream of random numbers came from a genuine Intel CPU that generated the numbers using the on-board random number
generation circuitry.

.. important:: If any terminology on this page is unfamiliar to you, start by reading ":doc:`what-is-sgx`".

.. warning:: Despite using Java, at this time only Linux is supported as a development platform. If you use other platforms
   like macOS or Windows you can set up a shared network drive to hold your project and issue build / run commands via SSH.

The RDRAND circuit
------------------

How are the random numbers generated? It's worth taking a moment to review the source of the entropy this enclave
will serve.

All Intel CPUs contain a hardware random number generator based on physical sources of randomness. It works by sampling
and then post-processing tiny variations in thermal noise generated by the CPU and its environment. The root of the
generator is a self-clocked metastable oscillator running at 3 GHz, which is then sampled and the randomness verified
by post-processing circuitry. If the metastable circuit were to fail or get stuck then it would stop contributing
entropy to the pool.

You can read a `third party audit by Cryptography Research Inc of Intel's RNG <_static/Intel_TRNG_Report_20120312.pdf>`_.
It goes into extensive detail as to the design and implementation of the feature.

Build modes
-----------

There are three ways to build an enclave:

1. Simulation mode
2. Debug mode
3. Release mode

In simulation mode no SGX hardware is required. It's convenient for testing. In debug mode, a real SGX enclave will
be instantiated and run, however a back door is left in that allows the untrusted world to read and write enclave
memory despite the usual protections. This is good for (as the name implies) debugging, but it also serves a second
purpose. To close the back door by using release mode, your enclave must be signed by an Intel whitelisted key. Intel
will revoke keys that are being used to create malware using SGX to implement CryptoLocker style viruses or avoid
reverse engineering.

.. important:: Future versions of SGX support "flexible launch policy" which allows the owner of a machine to whitelist
   their own enclaves. Intel's own signing infrastructure will become used primarily for enclaves running on,
   e.g. consumer Windows machines.

How to build the enclave
------------------------

.. sourcecode:: bash

    ./gradlew samples:rng:rng-enclave:buildSignedEnclaveSimulation

The above will build an enclave linked against **simulation libraries** in
``samples/rng/rng-enclave/build/enclave/Simulation/enclave.signed.so``. This means this enclave won't be loaded as a
proper SGX enclave, but will use simulated behaviour instead. This is useful for development/debugging or playing around
with the tech without access to SGX.

To build a properly linked enclave use:

.. sourcecode:: bash

    ./gradlew samples:rng:rng-enclave:buildSignedEnclaveDebug # Build enclave with debug symbols.
    ./gradlew samples:rng:rng-enclave:buildSignedEnclaveRelease # Build an optimized enclave with stripped symbols.

The above enclaves can be loaded onto an SGX device, however loading
these requires further setup. See :ref:`sgx-setup`.

To test the build enclave:

.. sourcecode:: bash

    ./gradlew samples:rng:rng-enclave:test

The above will build and sign a Simulation enclave with a dummy MRSIGNER key and run a test against it.
The test loads the enclave, requests some random numbers, and checks the enclave signature.

The Gradle build
----------------

Oblivium projects are built using the popular Gradle tool. The build process for an enclave is complex and involves
statically linking a fat JAR file into a native binary and (in release mode) signing it. Several Gradle plugins are
provided to simplify this.

Here is the basic template you should use:

.. literalinclude:: ../../samples/rng/rng-enclave/build.gradle
   :language: groovy
   :start-after: DOCS_ENCLAVE_BUILD_BEGIN
   :end-before: DOCS_ENCLAVE_BUILD_END

Set ``oblivium_version=`` to |oblivium_version| and ``kotlin_version`` to |kotlin_version| or whatever version of Kotlin
you want to use in your ``settings.gradle`` file. Kotlin is not required to use Oblivium, but the RNG enclave does use it.

Most of this is standard Gradle logic, so if it's not clear please refer to the Gradle user guide. We use the "shadow JAR"
plugin to build a single JAR file containing all the class files and resources our program needs, including bundled
dependencies, then we set the ``Enclave-Class`` manifest attribute. This points to the ``Enclavelet`` entrypoint that
Oblivium will load and is analogous to the ``Main-Class`` attribute executable JARs normally use. We make the test
tasks depend on ``buildSignedEnclaveSimulation``, therefore we will run our unit tests in simulation mode. No
SGX hardware will be required, so this can run on normal CI clusters.

.. note:: You should set the ``archiveBaseName`` property appropriately for your app

Then we configure the test task to set a system property indicating where the enclave can be found, during test runs.

Finally, we use the ``enclaveRelease`` DSL to switch off dummy key signing for the Release build of the enclave. In
order to load an enclave in non-DEBUG mode in production (which is the only secure way of loading an enclave), you must
sign it with a key whitelisted by Intel. The plugin by default uses a dummy key for signing, which is naturally not
whitelisted. ``shouldUseDummyKey = false`` switches this convenience behaviour off, and the plugin thus expects the
signature to be provided externally. Specifically the MRSIGNER public key (``mrsigner.public.pem``) and the signature
(``mrsigner.signature.bin``) must be placed into ``src/sgx/Release``.

The Enclavelet class
--------------------

The RNG enclave is written in Kotlin, but the Java equivalent would be straightforward. It is defined like this:

.. literalinclude:: ../../samples/rng/rng-enclave/src/main/kotlin/com/r3/sgx/rng/enclave/RngEnclave.kt
   :language: kotlin
   :start-after: DOCS_RNG_ENCLAVE_BEGIN
   :end-before: DOCS_RNG_ENCLAVE_END

It has two tasks: create the **report data** that will be included in the remote attestation (along with the enclave
measurement), and creating the handler.

Report data
~~~~~~~~~~~

The report data is 64 bytes (and it **must** be 64 bytes) of arbitrary data that will be signed by the CPU as part of
the remote attestation protocol. This can be used to bind an encrypted channel to the enclave through the attestation
process, thus allowing a user to be sure they're communicating with the enclave and not a man-in-the-middle.

In this use case, the user isn't actually uploading anything to us, just downloading. Also random numbers are by definition
not valuable secrets until they're used for something else, like deriving an encryption key, but that is not being done
here. So rather than set up an encrypted communication, we simply generate a signing key and place it in the report data.

The ``EnclaveApi`` provides access to functionality provided by Oblivium. Inside the enclave many ordinary Java APIs
do not work, because they would rely on functionality only accessible by the untrusted world, so you may have to go
via this API instead.

.. note:: The Oblivium team always endeavours to provide SGX compatible implementations of the standard Java API whenever
   technically possible.

Here, we use it to generate an ed25519 signing key. Ed25519 is a modern elliptic curve signature algorithm with many
desirable properties, such as making it easy to build side-channel resistant implementations. We then securely hash the key
to make it fit in 64 bytes, and wrap it in a ``ByteBuffer``.

Finally, we return a ``Cursor`` into this ``ByteBuffer``, giving it a type of ``SgxReportData``. ``SgxReportData`` is
one of a collection of singleton objects that define the layout of binary structures used in the SGX protocols and schemes.

Creating the handler
~~~~~~~~~~~~~~~~~~~~

When a new user connects to the enclave, the ``createHandler`` method is called. It must return an object that will
receive messages sent on that user's connection. In this way, you can easily create enclaves that can serve many
clients at once.

The ``RngHandler`` class looks like this:

.. literalinclude:: ../../samples/rng/rng-enclave/src/main/kotlin/com/r3/sgx/rng/enclave/RngHandler.kt
   :language: kotlin
   :start-after: DOCS_RNG_HANDLER_BEGIN
   :end-before: DOCS_RNG_HANDLER_END

The constructor of the class takes the ``EnclaveApi``, along with the key we previously generated. We could also have
made this an inner class rather than passing in state explicitly.

The handler derives from ``BytesHandler``, a simple convenience handler that lets you send and receive arbitrary byte
arrays. It implements the following steps:

1. Read how many random bytes the user wants, with one kilobyte being the maximum.
2. Use the enclavelet API to generate the random numbers using RDRAND.
3. Computes a signature over the buffer of random bytes.
4. Places the signature, public key and random bytes into a byte array and finally, sends it back using the ``Connection``
   object, which represents the active connection.

In most apps you'd use higher level handlers that let you work in terms of serialised data structures, but using a lower
level API here makes it clear what's going on.

Connection management
~~~~~~~~~~~~~~~~~~~~~

You may be wondering how connections work, and when the ``RngHandler`` is disposed. The answer is that connection lifecycle
is managed by the host server running in the untrusted world. When the host is notified that the user has disconnected,
timed out or the host decides the user is wasting its resources, it will disconnect the channel, which sends a "disconnected"
message into the handler tree. The ``ChannelHandlingHandler`` that the ``Enclavelet`` class sets up for you will then notice
and remove the handler from the tree. If you haven't kept a reference to it around anywhere, the garbage collector will
eventually clean up the handler and its resources.

.. note:: There is currently no API for the enclave itself to force a channel disconnect.

.. _enclave_xml:

enclave.xml
~~~~~~~~~~~

At this time you are required to create a file called ``enclave.xml`` for each enclave build type in
``src/sgx/Simulation``, ``src/sgx/Debug`` and ``src/sgx/Release`` in your project. This file contains various values
that configure the SGX SDK enclave build process, and looks like this:

.. literalinclude:: ../../samples/rng/rng-enclave/src/sgx/Release/enclave.xml
   :language: xml


The important values here are:

* ``ProdID`` - This is a number identifying your enclave's functionality. If you create another type of enclave it
  should be assigned a different number. This together with ``ISVSVN`` is used internally when deriving
  certain sealing keys.
* ``ISVSVN`` - This is a version number of your enclave and should be incremented whenever you release a new version of.
  A sealing key derived using an older ``ISVSVN`` can be re-derived with a newer one. In this way secrets encrypted
  with older enclaves may be decrypted with newer ones. Note that this only works if the enclave is sealing to
  MRSIGNER, and only when the two enclaves have the same ``ProdID``.
* ``HeapMaxSize`` - This is the maximum amount of memory available to the enclave, in hex.
* ``DisableDebug`` - This needs to be set to 1 when building a Release mode enclave.
* ``TCSNum`` - The number of available Thread Control Structures. This bounds the number of threads that may enter the
  enclave at the same time. Note that the enclave JVM requires two TCSs for its own operation, so this number should be
  set to <number of threads you want to create>+2. This number should also be aligned with the enclave host's thread
  pool settings.
