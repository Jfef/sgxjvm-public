RNG enclavelet
##############

`The RNG enclavelet project can be found on GitHub here <https://github.com/corda/oblivium-rng-enclave>`_.

Overview
--------

This project shows you how to generate and sign random numbers. Users who remotely attest with the enclave can be sure
that the stream of random numbers came from a genuine Intel CPU that generated the numbers using the on-board random number
generation circuitry.

.. important:: If any terminology on this page is unfamiliar to you, start by reading ":doc:`what-is-sgx`".

.. warning:: Despite using Java, at this time only Linux is supported as a development platform. If you use other platforms
   like macOS or Windows you can set up a shared network drive to hold your project and issue build / run commands via SSH.

The RDRAND circuit
------------------

How are the random numbers generated? It's worth taking a moment to review the source of the entropy this enclave
will serve.

All Intel CPUs contain a hardware random number generator based in physics based effects. It works by sampling and
then post-processing tiny variations in thermal noise generated by the CPU and its environment. The root of the
generator is a self-clocked metastable oscillator running at 3 GHz, which is then sampled and the randomness verified
by post-processing circuitry. If the metastable circuit were to fail or get stuck then it would stop contributing
entropy to the pool.

You can read a `third party audit by Cryptography Research Inc of Intel's RNG <_static/Intel_TRNG_Report_20120312.pdf>`_.
It goes into extensive detail as to the design and implementation of the feature.

Build modes
-----------

There are three ways to build an enclave:

1. Simulation mode
2. Debug mode
3. Release mode

In simulation mode no SGX hardware is required. It's convenient for testing. In debug mode, a real SGX enclave will
be instantiated and run, however a back door is left in that allows the untrusted world to read and write enclave
memory despite the usual protections. This is good for (as the name implies) debugging, but it also serves a second
purpose. To close the back door by using release mode, your enclave must be signed by an Intel whitelisted key. Intel
will revoke keys that are being used to create malware using SGX to implement CryptoLocker style viruses or avoid
reverse engineering.

.. important:: Future versions of SGX support "flexible launch policy" which allows the owner of a machine to whitelist
   their own enclaves. Intel's own signing infrastructure will become used primarily for enclaves running on,
   e.g. consumer Windows machines.

The Gradle build
----------------

Oblivium projects are built using the popular Gradle tool. The build process for an enclave is complex and involves
statically linking a fat JAR file into a native binary and (in release mode) signing it. Several Gradle plugins are
provided to simplify this.

Here is the basic template you should use:

.. sourcecode:: groovy

   buildscript {
       repositories {
           maven {
               url = "https://ci-artifactory.corda.r3cev.com/artifactory/oblivium"
           }
       }
       dependencies {
           classpath "com.r3.sgx:sgx-jvm-plugin-enclave:$oblivium_version"
           classpath "com.r3.sgx:sgx-jvm-plugin-host:$oblivium_version"
       }
   }

   plugins {
       id 'org.jetbrains.kotlin.jvm'
       id 'com.r3.sgx.enclave'
       id 'com.r3.sgx.host'
   }

   repositories {
       jcenter()
       mavenLocal()
       maven {
           url = "https://ci-artifactory.corda.r3cev.com/artifactory/oblivium"
       }
   }

   dependencies {
       implementation "org.jetbrains.kotlin:kotlin-stdlib-jdk8:$kotlin_version"
       implementation "com.r3.sgx:api-core-enclave:$oblivium_version"

       testImplementation "org.jetbrains.kotlin:kotlin-test:$kotlin_version"
       testImplementation "com.r3.sgx:api-core-host:$oblivium_version"
       testImplementation "com.r3.sgx:enclave-testing:$oblivium_version"
       testRuntimeOnly "com.r3.sgx:native-host-simulation:$oblivium_version"
   }

   shadowJar {
       baseName = "rng-enclave"
       zip64 = true

       manifest {
           attributes("Enclave-Class": "com.r3.sgx.rng.enclave.RngEnclave")
       }
   }

   test {
       dependsOn signEnclaveWithDummyKeySimulation
       systemProperty("com.r3.sgx.enclave.path", signEnclaveWithDummyKeySimulation.signedEnclavePath)
   }

   enclaveImageDebug {
       enclaveObject = tasks.getByName('signEnclaveWithDummyKeyDebug').outputSignedEnclave
   }

Put ``oblivium_version=1.0-nightly-+`` and ``kotlin_version=1.3.11`` or whatever version of Kotlin you want to use
in your ``settings.gradle`` file. Kotlin is not required to use Oblivium, but the RNG enclave does use it.

Most of this is standard Gradle logic, so if it's not clear please refer to the Gradle user guide. We use the "shadow JAR"
plugin to build a single JAR file containing all the class files and resources our program needs, including bundled
dependencies, then we set the ``Enclave-Class`` manifest attribute. This points to the ``Enclavelet`` entrypoint that
Oblivium will load and is analogous to the ``Main-Class`` attribute executable JARs normally use. We make the test
tasks depend on ``signEnclaveWithDummyKeySimulation``, therefore we will run our unit tests in simulation mode. No
SGX hardware will be required, so this can run on normal CI clusters.

**You should set the ``baseName`` property appropriately for your app**

Then we configure the test task to set a system property indicating where the enclave can be found, during test runs.

Finally, we use the ``enclaveImageDebug`` DSL to request creation of a debug mode enclave file (not simulation). This
will be signed with a dummy key created for you during the build, which isn't whitelisted by Intel. Therefore this
enclave is not secure.

TODO: How to build a release enclave

The Enclavelet class
--------------------

The RNG enclave is written in Kotlin, but the Java equivalent would be straightforward. It is defined like this:

.. sourcecode:: kotlin

   class RngEnclave : Enclavelet() {
       private lateinit var signatureScheme: SignatureScheme
       private lateinit var keyPair: KeyPair

       override fun createReportData(api: EnclaveApi): Cursor<ByteBuffer, SgxReportData> {
           // Generate a key pair
           signatureScheme = api.signatureSchemeFactory.make(SchemesSettings.EDDSA_ED25519_SHA512)
           keyPair = signatureScheme.generateKeyPair()
           // Hash the public key, to be included in the report
           val keyDigest = MessageDigest.getInstance("SHA-512").digest(keyPair.public.encoded)
           // Construct a typed cursor over the bytes. SgxReportData is an [Encoder] which describes a JVM view over the
           // corresponding native C++ structure.
           return Cursor(SgxReportData, ByteBuffer.wrap(keyDigest))
       }

       override fun createHandler(api: EnclaveApi): Handler<*> {
           return RngHandler(keyPair, signatureScheme, api)
       }
   }

It has two tasks: create the *report data* that will be included in the remote attestation (along with the enclave
measurement), and creating the handler.

Report data
~~~~~~~~~~~

The report data is 64 bytes (and it **must** be 64 bytes) of arbitrary data that will be signed by the CPU as part of
the remote attestation protocol. This can be used to bind an encrypted channel to the enclave through the attestation
process, thus allowing a user to be sure they're communicating with the enclave and not a man-in-the-middle.

In this use case, the user isn't actually uploading anything to us, just downloading. Also random numbers are by definition
not valuable secrets until they're used for something else, like deriving an encryption key, but that being done here.
So rather than set up an encrypted communication, we simply generate a signing key and place it in the report data.

The ``EnclaveApi`` provides access to functionality provided by Oblivium. Inside the enclave many ordinary Java APIs
do not work, because they would rely on functionality only accessible by the untrusted world, so you may have to go
via this API instead.

.. note:: The Oblivium team always endeavours to provide SGX compatible implementations of the standard Java API whenever
   technically possible.

Here, we use it to generate an ed25519 signing key. Ed25519 is a modern elliptic curve signature algorithm with many
desirable properties, such as making it easy to build side-channel resistant implementations. We then securely hash the key
to make it fit in 64 bytes, and wrap it in a ``ByteBuffer``.

Finally, we return a ``Cursor`` into this ``ByteBuffer``, giving it a type of ``SgxReportData``. ``SgxReportData`` is
one of a collection of singleton objects that define the layout of binary structures used in the SGX protocols and schemes.

Creating the handler
~~~~~~~~~~~~~~~~~~~~

When a new user connects to the enclave, the ``createHandler`` method is called. It must return an object that will
receive messages sent on that user's connection. In this way, you can easily create enclaves that can serve many
clients at once.

The ``RngHandler`` class looks like this:

.. sourcecode:: kotlin

   class RngHandler(
           private val keyPair: KeyPair,
           private val signatureScheme: SignatureScheme,
           private val api: EnclaveApi
   ): BytesHandler() {
       override fun receive(connected: Connected, input: ByteBuffer) {
           // Get the size requested
           val sizeRequested = input.int
           val randomBytesSize = min(sizeRequested, 1024)

           // Generate the bytes. Under the hood the randomness is generated by the SGX-specific RDRAND instruction.
           val randomBytes = ByteArray(randomBytesSize)
           api.getRandomBytes(randomBytes, 0, randomBytesSize)

           // Sign the bytes
           val signature = signatureScheme.sign(keyPair.private, randomBytes)
           val publicKey = keyPair.public.encoded

           // Serialize the reply including the random bytes, public key and signature
           val size = 4 + randomBytes.size + 4 + publicKey.size + 4 + signature.size
           val buffer = ByteBuffer.allocate(size)
           buffer.putInt(randomBytes.size)
           buffer.put(randomBytes)
           buffer.putInt(publicKey.size)
           buffer.put(publicKey)
           buffer.putInt(signature.size)
           buffer.put(signature)
           buffer.rewind()

           // Finally send the reply
           connected.send(buffer)
       }
   }

The constructor of the class takes the ``EnclaveApi``, along with the key we previously generated. We could also have
made this an inner class rather than passing in state explicitly.

The handler derives from ``BytesHandler``, a simple convenience handler that lets you send and receive arbitrary byte
arrays. It implements the following steps:

1. Read how many random bytes the user wants, with one kilobyte being the minimum.
2. Use the enclavelet API to generate the random numbers using RDRAND.
3. Computes a signature over the buffer of random bytes.
4. Places the signature, public key and random bytes into a byte array and finally, sends it back using the ``Connected``
   object, which represents the active connection.

In most apps you'd use higher level handlers that let you work in terms of serialised data structures, but using a lower
level API here makes it clear what's going on.

Connection management
~~~~~~~~~~~~~~~~~~~~~

You may be wondering how connections work, and when the ``RngHandler`` is disposed. The answer is that connection lifecycle
is managed by the host server running in the untrusted world. When the host is notified that the user has disconnected,
timed out or the host decides the user is wasting its resources, it will disconnect the channel, which sends a "disconnected"
message into the handler tree. The ``ChannelHandlingHandler`` that the ``Enclavelet`` class sets up for you will then notice
and remove the handler from the tree. If you haven't kept a reference to it around anywhere, the garbage collector will
eventually clean up the handler and its resources.

.. note:: There is currently no API for the enclave itself to force a channel disconnect.

.. _enclave_xml:

enclave.xml
~~~~~~~~~~~

At this time you are required to create a file called ``enclave.xml`` in the resources directory of your project. This
contains various values that configure the SGX SDK enclave build process, and looks like this::

    <EnclaveConfiguration>
        <ProdID>0</ProdID>
        <ISVSVN>0</ISVSVN>
        <StackMaxSize>0x280000</StackMaxSize>
        <HeapMaxSize>0x8000000</HeapMaxSize>
        <TCSNum>10</TCSNum>
        <TCSPolicy>1</TCSPolicy>
        <DisableDebug>0</DisableDebug>
        <MiscSelect>0</MiscSelect>
        <MiscMask>0xFFFFFFFF</MiscMask>
    </EnclaveConfiguration>

The important values here are:

* ``ISVSVN`` - this is a version number of your enclave and should be incremented whenever you release a new version.
* ``HeapMaxSize`` - this is the maximum amount of memory available to the enclave, in hex.
* ``DisableDebug`` - this needs to be set to 1 when building a release mode enclave.

.. important:: In future versions of the platform this file will be generated for you automatically.
