package com.r3.sgx.rng.enclave

import com.r3.sgx.core.common.BytesHandler
import com.r3.sgx.core.common.Handler
import com.r3.sgx.core.common.SignatureScheme
import com.r3.sgx.core.enclave.EnclaveApi
import java.nio.ByteBuffer
import java.security.KeyPair
import kotlin.math.min

/**
 * The [Handler] of [RngEnclave] clients.
 *
 * It receives requests for random numbers consisting of a single integer no larger than 1024. Then it generates a
 * random sequence of bytes of this size, signs the bytes, and sends back a reply including the random numbers, the
 * enclave's public key, and the signature itself.
 *
 * Note that in a more realistic scenario the request and reply should be serialized by a proper serialization library,
 * like protobuf. However for the sake of reducing dependencies to the minimum we're serializing by hand using java
 * [ByteBuffer]s.
 */
// DOCS_RNG_HANDLER_BEGIN
class RngHandler(
        private val keyPair: KeyPair,
        private val signatureScheme: SignatureScheme,
        private val api: EnclaveApi
): BytesHandler() {
    override fun onReceive(connection: Connection, input: ByteBuffer) {
        // Get the size requested
        val sizeRequested = input.int
        val randomBytesSize = min(sizeRequested, 1024)

        // Generate the bytes. Under the hood the randomness is generated by the RDRAND instruction.
        val randomBytes = ByteArray(randomBytesSize)
        api.getRandomBytes(randomBytes, 0, randomBytesSize)

        // Sign the bytes
        val signature = signatureScheme.sign(keyPair.private, randomBytes)
        val publicKey = keyPair.public.encoded

        // Serialize the reply including the random bytes, public key and signature
        val size = 4 + randomBytes.size + 4 + publicKey.size + 4 + signature.size
        val buffer = ByteBuffer.allocate(size)
        buffer.putInt(randomBytes.size)
        buffer.put(randomBytes)
        buffer.putInt(publicKey.size)
        buffer.put(publicKey)
        buffer.putInt(signature.size)
        buffer.put(signature)
        buffer.rewind()

        // Finally send the reply
        connection.send(buffer)
    }
}
// DOCS_RNG_HANDLER_END
